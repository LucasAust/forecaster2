import { NextResponse } from 'next/server';
import { createClient } from '@/utils/supabase/server';
import { geminiClient } from '@/lib/gemini';
import { checkRateLimit, RATE_LIMITS } from '@/lib/rate-limit';
import type { Transaction, ClarificationAnswer } from '@/types';

/**
 * POST /api/transactions/clarify
 * Accepts a list of transactions, returns up to 5 clarification questions
 * about the most ambiguous ones (generated by Gemini).
 */
export async function POST(request: Request) {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    // Rate-limit clarification generation (uses Gemini, costs money)
    const rateCheck = checkRateLimit(`clarify:${user.id}`, RATE_LIMITS.forecast);
    if (!rateCheck.allowed) {
        return NextResponse.json(
            { error: `Rate limit exceeded. Try again in ${rateCheck.resetIn}s.` },
            { status: 429, headers: { 'Retry-After': String(rateCheck.resetIn) } }
        );
    }

    try {
        const body = await request.json() as { transactions: Transaction[] };
        const transactions = body.transactions;

        if (!Array.isArray(transactions) || transactions.length === 0) {
            return NextResponse.json({ questions: [] });
        }

        const result = await geminiClient.generateClarificationQuestions(transactions);
        return NextResponse.json(result);
    } catch (error) {
        console.error('Error generating clarification questions:', error);
        // Non-fatal â€” return empty so the app continues normally
        return NextResponse.json({ questions: [] });
    }
}

/**
 * PATCH /api/transactions/clarify
 * Accepts user's answers to clarification questions.
 * Updates the `category` field for those transactions in the DB so the
 * next forecast generation uses the corrected categories.
 */
export async function PATCH(request: Request) {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

    try {
        const body = await request.json() as { overrides: ClarificationAnswer[] };
        const overrides = body.overrides;

        if (!Array.isArray(overrides) || overrides.length === 0) {
            return NextResponse.json({ success: true });
        }

        // Update each transaction's category in the DB (max 5 updates)
        const limited = overrides.slice(0, 5);
        const results = await Promise.allSettled(
            limited.map(({ transaction_id, category }) =>
                supabase
                    .from('transactions')
                    .update({ category: [category] })
                    .eq('transaction_id', transaction_id)
                    .eq('user_id', user.id) // enforce ownership
            )
        );

        const failures = results.filter(r => r.status === 'rejected');
        if (failures.length > 0) {
            console.error('Some clarification updates failed:', failures);
        }

        return NextResponse.json({ success: true });
    } catch (error) {
        console.error('Error saving clarification answers:', error);
        return NextResponse.json({ error: 'Failed to save answers' }, { status: 500 });
    }
}
